import {
  __commonJS
} from "./chunk-6TJCVOLN.js";

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-rtsp-stream/mpeg1muxer.js
var require_mpeg1muxer = __commonJS({
  "node_modules/node-rtsp-stream/mpeg1muxer.js"(exports, module) {
    var Mpeg1Muxer;
    var child_process;
    var events;
    var util;
    child_process = require_child_process();
    util = require_util();
    events = require_events();
    Mpeg1Muxer = function(options) {
      var key;
      this.url = options.url;
      this.ffmpegOptions = options.ffmpegOptions;
      this.exitCode = void 0;
      this.additionalFlags = [];
      if (this.ffmpegOptions) {
        for (key in this.ffmpegOptions) {
          this.additionalFlags.push(key);
          if (String(this.ffmpegOptions[key]) !== "") {
            this.additionalFlags.push(String(this.ffmpegOptions[key]));
          }
        }
      }
      this.spawnOptions = [
        "-i",
        this.url,
        "-f",
        "mpegts",
        "-codec:v",
        "mpeg1video",
        // additional ffmpeg options go here
        ...this.additionalFlags,
        "-"
      ];
      this.stream = child_process.spawn(options.ffmpegPath, this.spawnOptions, {
        detached: false
      });
      this.inputStreamStarted = true;
      this.stream.stdout.on("data", (data) => {
        return this.emit("mpeg1data", data);
      });
      this.stream.stderr.on("data", (data) => {
        return this.emit("ffmpegStderr", data);
      });
      this.stream.on("exit", (code, signal) => {
        if (code === 1) {
          console.error("RTSP stream exited with error");
          this.exitCode = 1;
          return this.emit("exitWithError");
        }
      });
      return this;
    };
    util.inherits(Mpeg1Muxer, events.EventEmitter);
    module.exports = Mpeg1Muxer;
  }
});

// node_modules/node-rtsp-stream/videoStream.js
var require_videoStream = __commonJS({
  "node_modules/node-rtsp-stream/videoStream.js"(exports, module) {
    var Mpeg1Muxer;
    var STREAM_MAGIC_BYTES;
    var VideoStream;
    var events;
    var util;
    var ws;
    ws = require_browser();
    util = require_util();
    events = require_events();
    Mpeg1Muxer = require_mpeg1muxer();
    STREAM_MAGIC_BYTES = "jsmp";
    VideoStream = function(options) {
      this.options = options;
      this.name = options.name;
      this.streamUrl = options.streamUrl;
      this.width = options.width;
      this.height = options.height;
      this.wsPort = options.wsPort;
      this.inputStreamStarted = false;
      this.stream = void 0;
      this.startMpeg1Stream();
      this.pipeStreamToSocketServer();
      return this;
    };
    util.inherits(VideoStream, events.EventEmitter);
    VideoStream.prototype.stop = function() {
      this.wsServer.close();
      this.stream.kill();
      this.inputStreamStarted = false;
      return this;
    };
    VideoStream.prototype.startMpeg1Stream = function() {
      var gettingInputData, gettingOutputData, inputData, outputData;
      this.mpeg1Muxer = new Mpeg1Muxer({
        ffmpegOptions: this.options.ffmpegOptions,
        url: this.streamUrl,
        ffmpegPath: this.options.ffmpegPath == void 0 ? "ffmpeg" : this.options.ffmpegPath
      });
      this.stream = this.mpeg1Muxer.stream;
      if (this.inputStreamStarted) {
        return;
      }
      this.mpeg1Muxer.on("mpeg1data", (data) => {
        return this.emit("camdata", data);
      });
      gettingInputData = false;
      inputData = [];
      gettingOutputData = false;
      outputData = [];
      this.mpeg1Muxer.on("ffmpegStderr", (data) => {
        var size;
        data = data.toString();
        if (data.indexOf("Input #") !== -1) {
          gettingInputData = true;
        }
        if (data.indexOf("Output #") !== -1) {
          gettingInputData = false;
          gettingOutputData = true;
        }
        if (data.indexOf("frame") === 0) {
          gettingOutputData = false;
        }
        if (gettingInputData) {
          inputData.push(data.toString());
          size = data.match(/\d+x\d+/);
          if (size != null) {
            size = size[0].split("x");
            if (this.width == null) {
              this.width = parseInt(size[0], 10);
            }
            if (this.height == null) {
              return this.height = parseInt(size[1], 10);
            }
          }
        }
      });
      this.mpeg1Muxer.on("ffmpegStderr", function(data) {
        return global.process.stderr.write(data);
      });
      this.mpeg1Muxer.on("exitWithError", () => {
        return this.emit("exitWithError");
      });
      return this;
    };
    VideoStream.prototype.pipeStreamToSocketServer = function() {
      this.wsServer = new ws.Server({
        port: this.wsPort
      });
      this.wsServer.on("connection", (socket, request) => {
        return this.onSocketConnect(socket, request);
      });
      this.wsServer.broadcast = function(data, opts) {
        var results;
        results = [];
        for (let client of this.clients) {
          if (client.readyState === 1) {
            results.push(client.send(data, opts));
          } else {
            results.push(console.log("Error: Client from remoteAddress " + client.remoteAddress + " not connected."));
          }
        }
        return results;
      };
      return this.on("camdata", (data) => {
        return this.wsServer.broadcast(data);
      });
    };
    VideoStream.prototype.onSocketConnect = function(socket, request) {
      var streamHeader;
      streamHeader = new Buffer(8);
      streamHeader.write(STREAM_MAGIC_BYTES);
      streamHeader.writeUInt16BE(this.width, 4);
      streamHeader.writeUInt16BE(this.height, 6);
      socket.send(streamHeader, {
        binary: true
      });
      console.log(`${this.name}: New WebSocket Connection (` + this.wsServer.clients.size + " total)");
      socket.remoteAddress = request.connection.remoteAddress;
      return socket.on("close", (code, message) => {
        return console.log(`${this.name}: Disconnected WebSocket (` + this.wsServer.clients.size + " total)");
      });
    };
    module.exports = VideoStream;
  }
});

// node_modules/node-rtsp-stream/index.js
var require_node_rtsp_stream = __commonJS({
  "node_modules/node-rtsp-stream/index.js"(exports, module) {
    module.exports = require_videoStream();
  }
});
export default require_node_rtsp_stream();
//# sourceMappingURL=node-rtsp-stream.js.map
